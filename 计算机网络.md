### TCP 可靠传输的实现

TCP 的可靠传输靠三个方面：

- 确认 和 超时重传
- 流量控制
- 拥塞控制

#### 确认 和 超时重传

TCP 使用确认和重传机制来确保数据的可靠传输。发送方在发送数据后等待接收方的确认消息。如果发送方在一定时间内未收到确认消息，则会假定数据丢失，重新发送数据。

涉及的协议：停止等待协议和 ARQ 协议

#### 流量控制

流量控制是通过**滑动窗口**实现的。滑动窗口的存在是为了让接收方告诉发送方，自己还能接受多少字节的数据，以免接收方的 TCP 输入缓存溢出，造成数据丢失。

滑动窗口可以使用 **连续 ARQ 协议**：

- 对于发送方，可以将窗口内的分组连续发送，而无需等待接收方的确认
- 对于发送方，采用**累计确认**，只需对按序到达的最后一个分组发送确认

如果使用了 连续 ARQ 协议，对于分组并没有丢失，而是未按序到达的情况该如何处理呢。

这涉及了 **选择确认 SACK**：

- 要使用选择确认 SACK ，需要双方商定好，在 TCP 的首部增加 SACK 选项
- 一个边界需要用到 4 字节，因此指明一个 字节块（区间）需要用到 8 字节。还需要另外 2 个字节，一个字节指明是 SACK 选项，另一个字节指明这个选项要占用多少字节。综述， TCP 的 首部40 字节的选项长度最多只能指明 4 个字节块 的边界信息，共需要用到 34 字节。

#### 拥塞控制

拥塞控制 与 流量控制 都是通过 抑制发送方发送数据的速率 来达到目的，但是：

- 流量控制是端到端的控制，只涉及建立通信的双方，只是为了让接收方来得及接收数据
- 拥塞控制是为了防止过多的数据注入到网络中，使得网络能够承受现有的网络负荷

拥塞控制分为四个部分：

- 慢启动
- 拥塞避免
- 快重传
- 快恢复

##### 慢开始

慢开始的思路是这样的：当主机在已建立的 TCP 连接上开始发送数据时，并不清楚网络当前的负荷情况，如果立即将大量数据注入到网络中，可能会引发网络拥塞。

因此，慢开始设置 **cwnd**(congestion window ，拥塞窗口) 为 1（一个 cwnd 的字节数由 发送方的 最大报文段 SSMS 的数值确定），而后指数级增长。

##### 拥塞避免

为了防止cwnd 过度增长，需要设置一个 **慢开始门限 ssthresh** ，当 cwnd 达到 慢开始门限时，开始使用拥塞避免算法，即，在拥塞避免阶段，cwnd 不再指数级增长，而是线性增长。

当网络出现拥堵（发生超时）时，慢开始门限值会变成 $cwnd / 2$ ，并且将 $cwnd = 1$ ，开始执行慢开始算法。

##### 快重传

有时，个别报文段会在网络中意外丢失，而此时网络并没有出现拥堵。接收方产生超时，误以为网络拥堵，开始执行慢开始算法，降低了传输效率。

采用 快重传 算法可以让发送方尽早直到发生了个别报文段的丢失，避免超时。

- 接收方要理解发出对接收数据的确认
- 当数据乱序到达时，接收方必须对有序到达的最后一个数据发送重复确认，当发送三次时，发送方就能直到有数据丢失，重新发送丢失的数据，而不必等到超时。

##### 快恢复

当出现数据丢失的情况（接收方收到三次确认），不是启动慢开始，而是快恢复算法：

- 将 $ssthresh = cwnd /2$ , $cwnd = ssthresh$
- 执行拥塞避免算法



### TCP 的三次握手和四次挥手

#### 三次握手

- 我们首先看 握手过程：

	![三次握手](D:\typora\md文件\imgs\三次握手.png)

- 然后看 socket 编程中，连接建立的过程

    ```c
    int socket(int domain, int type, int protocol);
    int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);
    int listen(int sockfd, int backlog);
    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
    
    int connect(int sockfd, struct sockaddr *serv_addr, socklen_t addrlen);
    ```

我们发现：

- 服务器需要先 `listen()` ，客户端才能 `connect()`，这是第一次握手，而后服务器处于 `SYN-RCVD` 状态，直到客户端发来第三次握手为止。那么很明显，我们观察不到这个状态，因为：
    - 在调用 `listen()` 前，客户端无法发送第一次握手包。
    - 在调用 `listen()` 后，就已经完成握手了（悲，甚至不用 `accept()`)
    
- 在服务器 `accept()` 前，客户端就可以 `write()` 数据了

- 当有多个连接时，服务端的端口始终是同一个

    ![image-20240414145005992](D:\typora\md文件\imgs\image-20240414145005992.png)



#### 四次挥手

![四次挥手](D:\typora\md文件\imgs\四次挥手.png)

还是观察不到，悲。不纠结了。

###  TCP的运输连接管理

运输连接的管理就是使运输连接的简历和释放都能正常地进行
运输连接的三个阶段：**连接建立、数据传送和连接释放**

#### TCP的连接建立

在TCP连接建立过程中要解决以下三个问题：

1. 要使每一方能够确知对方的存在。
2. 要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）
3. 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。

TCP建立连接的过程叫做握手，握手需要在客户端和服务器之间交换三个TCP报文段。